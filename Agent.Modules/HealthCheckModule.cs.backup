using Agent.Abstractions;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

namespace Agent.Modules;

public sealed class HealthCheckModule : AgentModuleBase
{
    private static readonly IReadOnlyCollection<string> Actions = new[]
    {
        "health",
        "metrics",
        "uptime"
    };

    private static readonly DateTime StartTime = DateTime.UtcNow;
    private static readonly Stopwatch Uptime = Stopwatch.StartNew();
    private readonly Process _currentProcess = Process.GetCurrentProcess();

    public HealthCheckModule(ILogger<HealthCheckModule> logger) : base(logger)
    {
    }

    public override string Name => "HealthCheckModule";

    public override IReadOnlyCollection<string> SupportedActions => Actions;

    public override async Task<bool> HandleAsync(AgentCommand command, AgentContext context)
    {
        switch (command.Action.ToLowerInvariant())
        {
            case "health":
                await HandleHealthAsync(command, context).ConfigureAwait(false);
                return true;
            case "metrics":
                await HandleMetricsAsync(command, context).ConfigureAwait(false);
                return true;
            case "uptime":
                await HandleUptimeAsync(command, context).ConfigureAwait(false);
                return true;
            default:
                return false;
        }
    }

    private async Task HandleHealthAsync(AgentCommand command, AgentContext context)
    {
        var health = GetHealthStatus();
        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            health)).ConfigureAwait(false);
    }

    private JsonObject GetHealthStatus()
    {
        _currentProcess.Refresh();

        var uptime = Uptime.Elapsed;
        var memoryMB = _currentProcess.WorkingSet64 / (1024.0 * 1024.0);
        var cpuTime = _currentProcess.TotalProcessorTime;

        var health = new JsonObject
        {
            ["status"] = "healthy",
            ["timestamp"] = DateTimeOffset.UtcNow.ToString("O"),
            ["startTime"] = StartTime.ToString("O"),
            ["uptime"] = FormatTimeSpan(uptime),
            ["uptimeSeconds"] = uptime.TotalSeconds,
            ["processId"] = _currentProcess.Id,
            ["processName"] = _currentProcess.ProcessName,
            ["machineName"] = Environment.MachineName,
            ["osVersion"] = Environment.OSVersion.VersionString,
            ["framework"] = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription,
            ["memory"] = new JsonObject
            {
                ["workingSetMB"] = Math.Round(memoryMB, 2),
                ["privateMemoryMB"] = Math.Round(_currentProcess.PrivateMemorySize64 / (1024.0 * 1024.0), 2),
                ["virtualMemoryMB"] = Math.Round(_currentProcess.VirtualMemorySize64 / (1024.0 * 1024.0), 2),
                ["gcTotalMemoryMB"] = Math.Round(GC.GetTotalMemory(false) / (1024.0 * 1024.0), 2)
            },
            ["cpu"] = new JsonObject
            {
                ["totalProcessorTimeSeconds"] = cpuTime.TotalSeconds,
                ["userProcessorTimeSeconds"] = _currentProcess.UserProcessorTime.TotalSeconds,
                ["privilegedProcessorTimeSeconds"] = _currentProcess.PrivilegedProcessorTime.TotalSeconds
            },
            ["threads"] = _currentProcess.Threads.Count,
            ["handles"] = _currentProcess.HandleCount
        };

        // Health check - mark as unhealthy if issues detected
        if (memoryMB > 500) // More than 500 MB
        {
            health["status"] = "degraded";
            health["warning"] = "High memory usage";
        }

        if (_currentProcess.Threads.Count > 100)
        {
            health["status"] = "degraded";
            health["warning"] = "High thread count";
        }

        return health;
    }

    private async Task HandleMetricsAsync(AgentCommand command, AgentContext context)
    {
        var metrics = GetMetrics();
        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            new JsonObject { ["metrics"] = metrics })).ConfigureAwait(false);
    }

    private JsonObject GetMetrics()
    {
        _currentProcess.Refresh();

        var metrics = new JsonObject();

        // Prometheus-style metrics
        var metricsArray = new JsonArray();

        metricsArray.Add(CreateMetric("agent_uptime_seconds", Uptime.Elapsed.TotalSeconds, "gauge", "Agent uptime in seconds"));
        metricsArray.Add(CreateMetric("agent_memory_working_set_bytes", _currentProcess.WorkingSet64, "gauge", "Process working set in bytes"));
        metricsArray.Add(CreateMetric("agent_memory_private_bytes", _currentProcess.PrivateMemorySize64, "gauge", "Process private memory in bytes"));
        metricsArray.Add(CreateMetric("agent_memory_virtual_bytes", _currentProcess.VirtualMemorySize64, "gauge", "Process virtual memory in bytes"));
        metricsArray.Add(CreateMetric("agent_memory_gc_bytes", GC.GetTotalMemory(false), "gauge", "GC total memory in bytes"));
        metricsArray.Add(CreateMetric("agent_cpu_total_seconds", _currentProcess.TotalProcessorTime.TotalSeconds, "counter", "Total CPU time in seconds"));
        metricsArray.Add(CreateMetric("agent_threads_count", _currentProcess.Threads.Count, "gauge", "Number of threads"));
        metricsArray.Add(CreateMetric("agent_handles_count", _currentProcess.HandleCount, "gauge", "Number of handles"));

        // GC metrics
        for (int gen = 0; gen <= GC.MaxGeneration; gen++)
        {
            var collectionCount = GC.CollectionCount(gen);
            metricsArray.Add(CreateMetric($"agent_gc_collection_count_gen{gen}", collectionCount, "counter", $"GC generation {gen} collection count"));
        }

        metrics["entries"] = metricsArray;
        metrics["timestamp"] = DateTimeOffset.UtcNow.ToString("O");

        return metrics;
    }

    private static JsonObject CreateMetric(string name, double value, string type, string help)
    {
        return new JsonObject
        {
            ["name"] = name,
            ["value"] = value,
            ["type"] = type,
            ["help"] = help
        };
    }

    private async Task HandleUptimeAsync(AgentCommand command, AgentContext context)
    {
        var uptime = Uptime.Elapsed;

        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            new JsonObject
            {
                ["uptime"] = FormatTimeSpan(uptime),
                ["uptimeSeconds"] = uptime.TotalSeconds,
                ["startTime"] = StartTime.ToString("O")
            })).ConfigureAwait(false);
    }

    private static string FormatTimeSpan(TimeSpan ts)
    {
        if (ts.TotalDays >= 1)
            return $"{(int)ts.TotalDays}d {ts.Hours}h {ts.Minutes}m";
        if (ts.TotalHours >= 1)
            return $"{(int)ts.TotalHours}h {ts.Minutes}m {ts.Seconds}s";
        if (ts.TotalMinutes >= 1)
            return $"{(int)ts.TotalMinutes}m {ts.Seconds}s";
        return $"{ts.Seconds}s";
    }

    public override async ValueTask DisposeAsync()
    {
        _currentProcess?.Dispose();
        await base.DisposeAsync().ConfigureAwait(false);
    }
}
