using Agent.Abstractions;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

namespace Agent.Modules;

public sealed class FileMonitoringModule : AgentModuleBase
{
    private static readonly IReadOnlyCollection<string> Actions = new[]
    {
        "startfilemonitor",
        "stopfilemonitor",
        "getfilechanges",
        "listmonitors"
    };

    private readonly ConcurrentDictionary<string, FileMonitorSession> _monitors = new(StringComparer.OrdinalIgnoreCase);

    public FileMonitoringModule(ILogger<FileMonitoringModule> logger) : base(logger)
    {
    }

    public override string Name => "FileMonitoringModule";

    public override IReadOnlyCollection<string> SupportedActions => Actions;

    public override async Task<bool> HandleAsync(AgentCommand command, AgentContext context)
    {
        switch (command.Action.ToLowerInvariant())
        {
            case "startfilemonitor":
                await HandleStartFileMonitorAsync(command, context).ConfigureAwait(false);
                return true;
            case "stopfilemonitor":
                await HandleStopFileMonitorAsync(command, context).ConfigureAwait(false);
                return true;
            case "getfilechanges":
                await HandleGetFileChangesAsync(command, context).ConfigureAwait(false);
                return true;
            case "listmonitors":
                await HandleListMonitorsAsync(command, context).ConfigureAwait(false);
                return true;
            default:
                return false;
        }
    }

    private async Task HandleStartFileMonitorAsync(AgentCommand command, AgentContext context)
    {
        if (!command.Payload.TryGetProperty("path", out var pathElement) || pathElement.ValueKind != JsonValueKind.String)
        {
            await SendNotImplementedAsync(command, context, "startfilemonitor requires 'path'.").ConfigureAwait(false);
            return;
        }

        var path = pathElement.GetString()!;
        var recursive = command.Payload.TryGetProperty("recursive", out var recElement) && recElement.GetBoolean();
        var filter = command.Payload.TryGetProperty("filter", out var filterElement) && filterElement.ValueKind == JsonValueKind.String
            ? filterElement.GetString()!
            : "*.*";
        var computeHash = command.Payload.TryGetProperty("computeHash", out var hashElement) && hashElement.GetBoolean();

        var monitorId = command.SessionId ?? Guid.NewGuid().ToString();

        if (_monitors.ContainsKey(monitorId))
        {
            await SendNotImplementedAsync(command, context, $"Monitor '{monitorId}' already exists.").ConfigureAwait(false);
            return;
        }

        try
        {
            var session = new FileMonitorSession(monitorId, path, filter, recursive, computeHash, Logger);
            session.Start();
            _monitors[monitorId] = session;

            Logger.LogInformation("File monitor started: {Path} ({MonitorId})", path, monitorId);

            await context.ResponseWriter.SendAsync(new CommandResult(
                command.Action,
                command.NodeId,
                command.SessionId,
                new JsonObject
                {
                    ["monitorId"] = monitorId,
                    ["path"] = path,
                    ["filter"] = filter,
                    ["recursive"] = recursive,
                    ["computeHash"] = computeHash,
                    ["started"] = true
                })).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start file monitor: {Path}", path);
            await SendNotImplementedAsync(command, context, $"Failed to start monitor: {ex.Message}").ConfigureAwait(false);
        }
    }

    private async Task HandleStopFileMonitorAsync(AgentCommand command, AgentContext context)
    {
        var monitorId = command.SessionId ?? "";

        if (_monitors.TryRemove(monitorId, out var session))
        {
            session.Stop();
            Logger.LogInformation("File monitor stopped: {MonitorId}", monitorId);
        }

        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            new JsonObject
            {
                ["monitorId"] = monitorId,
                ["stopped"] = true
            })).ConfigureAwait(false);
    }

    private async Task HandleGetFileChangesAsync(AgentCommand command, AgentContext context)
    {
        var monitorId = command.SessionId ?? "";

        if (!_monitors.TryGetValue(monitorId, out var session))
        {
            await SendNotImplementedAsync(command, context, $"Monitor '{monitorId}' not found.").ConfigureAwait(false);
            return;
        }

        var changes = session.GetChanges();

        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            new JsonObject
            {
                ["monitorId"] = monitorId,
                ["changes"] = changes,
                ["count"] = changes.Count
            })).ConfigureAwait(false);
    }

    private async Task HandleListMonitorsAsync(AgentCommand command, AgentContext context)
    {
        var monitors = new JsonArray();

        foreach (var kvp in _monitors)
        {
            monitors.Add(new JsonObject
            {
                ["monitorId"] = kvp.Key,
                ["path"] = kvp.Value.Path,
                ["filter"] = kvp.Value.Filter,
                ["recursive"] = kvp.Value.Recursive,
                ["changeCount"] = kvp.Value.ChangeCount
            });
        }

        await context.ResponseWriter.SendAsync(new CommandResult(
            command.Action,
            command.NodeId,
            command.SessionId,
            new JsonObject
            {
                ["monitors"] = monitors,
                ["count"] = monitors.Count
            })).ConfigureAwait(false);
    }

    public override async ValueTask DisposeAsync()
    {
        foreach (var session in _monitors.Values)
        {
            try
            {
                session.Stop();
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        _monitors.Clear();
        await base.DisposeAsync().ConfigureAwait(false);
    }

    private sealed class FileMonitorSession : IDisposable
    {
        private readonly string _monitorId;
        private readonly bool _computeHash;
        private readonly ILogger _logger;
        private readonly FileSystemWatcher _watcher;
        private readonly ConcurrentQueue<JsonObject> _changes = new();

        public FileMonitorSession(string monitorId, string path, string filter, bool recursive, bool computeHash, ILogger logger)
        {
            _monitorId = monitorId;
            Path = path;
            Filter = filter;
            Recursive = recursive;
            _computeHash = computeHash;
            _logger = logger;

            _watcher = new FileSystemWatcher(path, filter)
            {
                IncludeSubdirectories = recursive,
                NotifyFilter = NotifyFilters.FileName |
                              NotifyFilters.DirectoryName |
                              NotifyFilters.LastWrite |
                              NotifyFilters.Size |
                              NotifyFilters.CreationTime
            };

            _watcher.Created += OnFileEvent;
            _watcher.Changed += OnFileEvent;
            _watcher.Deleted += OnFileEvent;
            _watcher.Renamed += OnFileRenamed;
            _watcher.Error += OnError;
        }

        public string Path { get; }
        public string Filter { get; }
        public bool Recursive { get; }
        public int ChangeCount => _changes.Count;

        public void Start()
        {
            _watcher.EnableRaisingEvents = true;
        }

        public void Stop()
        {
            _watcher.EnableRaisingEvents = false;
        }

        public JsonArray GetChanges()
        {
            var changes = new JsonArray();
            var batch = new List<JsonObject>();

            // Dequeue up to 1000 events
            for (int i = 0; i < 1000 && _changes.TryDequeue(out var change); i++)
            {
                batch.Add(change);
            }

            foreach (var change in batch)
            {
                changes.Add(change);
            }

            return changes;
        }

        private void OnFileEvent(object sender, FileSystemEventArgs e)
        {
            try
            {
                var changeObj = new JsonObject
                {
                    ["timestamp"] = DateTimeOffset.UtcNow.ToString("O"),
                    ["changeType"] = e.ChangeType.ToString(),
                    ["fullPath"] = e.FullPath,
                    ["name"] = e.Name
                };

                if (_computeHash && File.Exists(e.FullPath))
                {
                    try
                    {
                        changeObj["hash"] = ComputeFileHash(e.FullPath);
                    }
                    catch (Exception ex)
                    {
                        changeObj["hashError"] = ex.Message;
                    }
                }

                if (File.Exists(e.FullPath))
                {
                    try
                    {
                        var fileInfo = new FileInfo(e.FullPath);
                        changeObj["size"] = fileInfo.Length;
                        changeObj["lastModified"] = fileInfo.LastWriteTimeUtc.ToString("O");
                    }
                    catch
                    {
                        // File might be locked
                    }
                }

                _changes.Enqueue(changeObj);

                // Limit queue size
                while (_changes.Count > 10000)
                {
                    _changes.TryDequeue(out _);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing file event: {Path}", e.FullPath);
            }
        }

        private void OnFileRenamed(object sender, RenamedEventArgs e)
        {
            try
            {
                var changeObj = new JsonObject
                {
                    ["timestamp"] = DateTimeOffset.UtcNow.ToString("O"),
                    ["changeType"] = "Renamed",
                    ["fullPath"] = e.FullPath,
                    ["name"] = e.Name,
                    ["oldFullPath"] = e.OldFullPath,
                    ["oldName"] = e.OldName
                };

                _changes.Enqueue(changeObj);

                while (_changes.Count > 10000)
                {
                    _changes.TryDequeue(out _);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing file rename: {Path}", e.FullPath);
            }
        }

        private void OnError(object sender, ErrorEventArgs e)
        {
            _logger.LogError(e.GetException(), "File monitor error: {MonitorId}", _monitorId);
        }

        private static string ComputeFileHash(string filePath)
        {
            using var sha256 = SHA256.Create();
            using var stream = File.OpenRead(filePath);
            var hash = sha256.ComputeHash(stream);
            return Convert.ToHexString(hash);
        }

        public void Dispose()
        {
            _watcher?.Dispose();
        }
    }
}
